# -*- coding: utf-8 -*-
"""Predicting the lost green cover in deforestation

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iJzEYmdXnirBTLKnVyYzi-9TuDgThSN6
"""

!pip install rasterio

# Commented out IPython magic to ensure Python compatibility.
import ee
import json
import time
import numpy as np
import matplotlib.pyplot as plt
import rasterio
from rasterio import plot
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline

ee.Authenticate()
ee.Initialize()

def selecting_band(sat, name, band_list):
  dataset = ee.ImageCollection((sat))
  dataset=dataset.filterDate('2015-01-01', '2015-01-31')
  img=dataset.select(band_list).median()
  print("Band selected - ", img.bandNames().getInfo())


  with open('/content/drive/My Drive/map_sgnp.geojson') as f:                    #open http://geojson.io/ and select area required and save it in a txt file with extension file_name.geojson. Move it to drive and provide the link over here
      data = json.load(f)
  for feature in data['features']:
      cord=feature['geometry']['coordinates']    


# Specify patch and file dimensions.
  image_export_options = {
    'patchDimensions': [256, 256],
    'maxFileSize': 104857600,
    'compressed': True
  }

  # Setup the task.
  image_task = ee.batch.Export.image.toDrive(
    image=img,
    description= name,
    fileNamePrefix= name,
    scale=30,
    fileFormat='GeoTiff',
    region=cord,
    formatOptions={
            "cloudOptimized": True
    },
  )
  image_task.start()
  # Block until the task completes.
  print('Running image export to Drive Storage...')
  while image_task.active():
    time.sleep(5)

  # Error condition
  if image_task.status()['state'] != 'COMPLETED':
    print('Error with image export.')
  else:
    print('Image export completed.')

  return None

landsat = { #"all_bands" :['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11'],
          # "band_6_and_7" : ['B5','B7'],
          # "band_5" : ['B4'],
          # "band_4" : ['B3'],
          "band_234" : ['B2','B3','B4']
          # "band_6_and_7" : ['B6','B7'],
          # "band_5" : ['B5'],
          # "band_4" : ['B4'],
          # "band_3" : ['B3']
         }

idaho = {
        "air temp" : 'tmmn'
        }

download_content = {
    "LANDSAT/LC08/C01/T1" : landsat ,
    # "IDAHO_EPSCOR/TERRACLIMATE" : idaho
}




for sat, band in download_content.items():
  print("Satellite selected: ", sat)
  print("-----------------------------------")
  for name, band_list in band.items():
    selecting_band(sat, name, band_list)
  print("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")

temp = rasterio.open( '/content/drive/My Drive/air temp.tif' )
band_3 = rasterio.open( '/content/drive/My Drive/band_3.tif' ) #green
band_4 = rasterio.open('/content/drive/My Drive/band_4.tif') #red
band_5 = rasterio.open( '/content/drive/My Drive/band_5.tif' ) #nir
band_6_and_7 = rasterio.open('/content/drive/My Drive/band_6_and_7.tif') #swir
band_234 = rasterio.open('/content/drive/My Drive/band_234.tif')

green = band_3.read(1).astype('float64')
red = band_4.read(1).astype('float64')
nir = band_5.read(1).astype('float64')
swir = (band_6_and_7.read(1).astype('float64')) + (band_6_and_7.read(2).astype('float64'))

def calculation_of_domain(red, nir, type, green = None, swir = None):

  #Calculate the forest area using band 4 and band 5 (nir and red)
  if(type == "forest"):
    forest=np.where(
        ((nir+red)==0. ), 
        0, 
        ((nir-red)/(nir+red)))

    forest = np.where(
        forest <= 0.2,
        0,
        forest
    )
    return forest

  #Calculate the crops area using band 4 and band 5 (nir and red)
  elif (type == "crops"):


    crops=np.where(
    ((nir+red)==0. ), 
    0, 
    ((nir-red)/(nir+red)))

    crops = np.where(
        crops <= 0.1,
        0,
        crops
    )
    crops = np.where(
        crops > 0.13,
        0,
        crops
    )
    return crops

  #Calculate the building area using band 3, band 4, band 5, band 6 and band 7 (green, red, nir , swir)
  elif (type == "buildings"):
    ibi =np.where(
        ( ((2 * swir/(swir +nir)) + (nir/(nir + red)) + (green/(green + red))) == 0. ), 
        0, 
        ((2 * swir/(swir +nir)) - (nir/(nir + red)) + (green/(green + red))) / ((2 * swir/(swir +nir)) + (nir/(nir + red)) + (green/(green + red))))



    forest=np.where(
        ((nir+red)==0. ), 
        0, 
        ((nir-red)/(nir+red)))

    forest = np.where(
        forest <= 0.2,
        0,
        1
    )



    ibi = np.where(
        ibi < 0.53, 
        0, 
        ibi)


    ibi = np.where(
        ibi > 0.544, 
        0, 
        ibi)
    

    ibi = np.where(
            forest == 1, 
            0, 
            ibi)



    return ibi

  elif (type == "burnt"):
    burn = np.where(
            ((nir+swir)==0. ), 
            0, 
            ((nir-swir)/(nir+swir)))
    forest=np.where(
        ((nir+red)==0. ), 
        0, 
        ((nir-red)/(nir+red)))

    forest = np.where(
        forest <= 0.2,
        0,
        1
    )

    burn = np.where(
            forest == 1, 
            burn, 
            0)
    return burn

domain_names = [ "forest",
                 "crops",
                 "buildings",
                 "burnt"
                ]
domain_dict = {}

for x in domain_names:
  domain_dict[x] = calculation_of_domain(red, nir, type = x, green = green, swir = swir)

def create_image(name, value):
  ndviImage = rasterio.open('/content/{}.tiff'.format(name),'w',
                            driver='Gtiff',
                            width=band_4.width, 
                            height = band_4.height, 
                            count=1, crs=band_4.crs, 
                            transform=band_4.transform, 
                            dtype='float64')
  ndviImage.write(value,1)
  ndviImage.close()

for name, value in domain_dict.items():
  create_image(name, value)

def plot_image(name):
  ndvi = rasterio.open('/content/{}.tiff'.format(name))
  link_images.append(ndvi)
  return link_images

link_images = []
for name, value in domain_dict.items():
  mapList = plot_image(name)

mapList.append(temp)

def plot_img_list(listOfImage):
  fig, axes = plt.subplots(1, len(listOfImage), figsize=(20, 20))
  for i in range(len(listOfImage)):
    plot.show(listOfImage[i], ax=axes[i])  
  fig.tight_layout();
plot_img_list(mapList)

